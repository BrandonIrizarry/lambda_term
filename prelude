# Boolean-related definitions.#

def first x y := x; def true := first;
def second x y := y; def false := second;
def if cond e1 e2 := (cond e1 e2);


# Natural number bootstrapping definitions.#

def zero := \x.x;
def iszero n := (n first);
def succ n := \s.(s false n);
def pred1 n := (n second);
def pred n := (if (iszero n) zero (pred1 n));


# Natural numbers from 1 to 10.#

def one := (succ zero);
def two := (succ one);
def three := (succ two);
def four := (succ three);
def five := (succ four);
def six := (succ five);
def seven := (succ six);
def eight := (succ seven);
def nine := (succ eight);
def ten := (succ nine);

# Define the Y combinator (our implementation of recursion relies on it.) #
def recursive f := (\s.(f (s s)) \s.(f (s s)));

# Define a function that reduces its argument to zero. #
def zero_out1 rec x := (if (iszero x)
                         zero
                         (rec (pred x)));

def zero_out := (recursive zero_out1);

# Define addition. #
def add1 rec x y := (if (iszero y)
                      x
                      (rec (succ x) (pred y)));

def add_v1 := (recursive add1);

(\_add.def add_v2 := (recursive _add) add1);

#
Here, the definition of add1 is being substituted
in place of the label 'add1'.

This does, in fact, result in a structurally differing (but semantically
equivalent) evaluation.
#
(\_add.def add_v3 := (recursive _add)
 \rec.\x.\y.(if (iszero y)
                 x
                 (rec (succ x) (pred y))));
